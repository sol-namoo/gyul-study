# eCommerce

## Pull Request

### 요약

product는 api로 받아오는 데이터라고 가정하고, 장바구니(cart)는 로컬에서 관리하는 객체로 가정했습니다.
장바구니 모달의 데이터(cartModalData) 역시 api 호출 결과라고 가정하여, 모달을 열 때마다 리스트를 새로 만들어 뿌렸습니다.

### 설명

최대한 고민 없이 익숙한 방법대로 하려고 노력했습니다.
그래도 만들면서 마음에 안 드는 부분이 보여서 막 고치고 싶더라구요.

은재님 강의 보면서 상위 요소에 이벤트 위임하는 부분을 보고 따라해 봐야지 생각하고 있었는데,
평소에는 값과 핸들러 함수를 전부 props로 전달하는 방식을 쓰다 보니까 자꾸 지저분해 보이더라구요.
두 방식이 코드 작성면 외에 실제 실행 시 연산 측면에서 얼마나 차이가 있을지 궁금합니다.

### 대략적인 실제 소요 시간

1시간 반 정도 걸렸습니다.

## Reviews

### 👍

- cart는 객체로, cartModalData는 배열로 관리한 점, 백엔드와의 연동을 고려하여 코드를 작성한 점

### 👎

- `export type Cart = Record<string, number>`
  Cart 타입을 보면 key가 string인데, 여기서 id는 number로 되어있어서
  `Record<Product['id'], number>` 이렇게 한다면 좀 더 안전하게 타입을 처리할 수 있겠다
- 카트에 추가/제거 시 if-else 문 대신 `...prev, [id]: (prev[id] || 0) + 1`로 한 줄에 적을 수 있겠다

### 리뷰 이후 PR에 덧붙인 내용

이벤트 위임을 쓰겠다는 아이디어는 결론적으로는 상황에 맞지 않는 아이디어였어요.
검색해 보니 react의 경우 사용자가 onclick 안에 핸들러 함수를 넣어두면 react가 알아서 이벤트 위임 방식으로 전환해준다고 해요.
그래서 react 공식 문서에서는 사용자가 직접 이벤트 위임을 구현하는 방식을 추천하지 않는다고 합니다 ㅎㅎ

저는 장바구니에 추가한 순서는 고려하지 않고 만들었지만, 여기에 순서 보장이라는 조건이 추가된다면 저는 cart는 객체로 유지하되 순서를 알려주는 배열을 하나 더 추가했을 것 같아요.
`const cartOrder = [] // [14, 5, 6, 7, 1] 와 같이 id를 채워넣고 다시 객체를 통해 개수에 접근`
