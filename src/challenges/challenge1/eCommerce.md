# eCommerce

## Pull Request

### 요약

product는 api로 받아오는 데이터라고 가정하고, 장바구니(cart)는 로컬에서 관리하는 객체로 가정했습니다.
장바구니 모달의 데이터(cartModalData) 역시 api 호출 결과라고 가정하여, 모달을 열 때마다 리스트를 새로 만들어 뿌렸습니다.

### 설명

최대한 고민 없이 익숙한 방법대로 하려고 노력했습니다.
그래도 만들면서 마음에 안 드는 부분이 보여서 막 고치고 싶더라구요.

은재님 강의 보면서 상위 요소에 이벤트 위임하는 부분을 보고 따라해 봐야지 생각하고 있었는데,
평소에는 값과 핸들러 함수를 전부 props로 전달하는 방식을 쓰다 보니까 자꾸 지저분해 보이더라구요.
두 방식이 코드 작성면 외에 실제 실행 시 연산 측면에서 얼마나 차이가 있을지 궁금합니다.

### 대략적인 실제 소요 시간

1시간 반 정도 걸렸습니다.

## Reviews on my PR

### Good 👍

- cart는 객체로, cartModalData는 배열로 관리한 점
- 백엔드와의 연동을 고려하여 코드를 작성한 점

### Not Good 👎

- `export type Cart = Record<string, number>`
  Cart 타입을 보면 key가 string인데, 여기서 id는 number로 되어있어서
  `Record<Product['id'], number>` 이렇게 한다면 좀 더 안전하게 타입을 처리할 수 있겠다
- 카트에 추가/제거 시 if-else 문 대신 `...prev, [id]: (prev[id] || 0) + 1`로 한 줄에 적을 수 있겠다

### 리뷰 이후 PR에 덧붙인 내용

이벤트 위임을 쓰겠다는 아이디어는 결론적으로는 상황에 맞지 않는 아이디어였어요.
검색해 보니 react의 경우 사용자가 onclick 안에 핸들러 함수를 넣어두면 react가 알아서 이벤트 위임 방식으로 전환해준다고 해요.
그래서 react 공식 문서에서는 사용자가 직접 이벤트 위임을 구현하는 방식을 추천하지 않는다고 합니다 ㅎㅎ

저는 장바구니에 추가한 순서는 고려하지 않고 만들었지만, 여기에 순서 보장이라는 조건이 추가된다면 저는 cart는 객체로 유지하되 순서를 알려주는 배열을 하나 더 추가했을 것 같아요.
`const cartOrder = [] // [14, 5, 6, 7, 1] 와 같이 id를 채워넣고 다시 객체를 통해 개수에 접근`

## WIL from others' PR

- 다음부터는 추상화, 책임 분리, 함수 네이밍 등 원칙과 가독성을 더 신경쓰는 PR을 작성해야지.
  - 핸들러 함수와 기능을 담당하는 함수를 분리하여 추상화하기.
- 외부 값을 읽어올 때 타입 가드로 방어하기. 사내 코드의 로컬스토리지 활용하는 부분에도 적용해야지.
  `const isCart = (value: unknown): value is Cart => {`
- 입력값의 최대/최소 범위 체크 시 Math.max 활용하여 간결하게 표현하기.
  `Math.max(amount, 0)`
- 함수 내부에서 state에 바로 접근이 가능하더라도 함수의 파라미터로 해당 state를 넘기자. 다음의 이유들 중 가장 공감하는 부분은 클로저 문제.
  - 변경이 발생했을 때 유지보수성이 높고
  - 코드의 의도를 명확하게 전달하고
  - 클로저로 인한 예기치 못한 버그를 방지하고
  - 테스트가 용이하다
